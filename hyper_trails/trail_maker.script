local trail_maker = require("hyper_trails.trail_maker")

go.property("use_world_position", false)
go.property("trail_width", 20)
go.property("trail_tint_color", vmath.vector4(1.0, 1.0, 1.0, 1.0))
go.property("segment_length_max", 0)
go.property("segment_length_min", 0)
go.property("points_count", 16)
go.property("points_limit", 0)
go.property("fade_tail_alpha", 0)
go.property("shrink_tail_width", false)
go.property("shrink_length_per_sec", 0)
go.property("texture_tiling", true)
go.property("trails_pool", msg.url("trails_pool#trails_pool"))
go.property("trail_model_url", msg.url("#trail_model"))
go.property("auto_update", true)

local function reset_trail(self)
	trail_maker.init_vars(self)
	trail_maker.init_buffers(self)
	trail_maker.init_props(self)
	trail_maker.init_data_points(self)
	trail_maker.draw_trail(self)
end

function init(self)
	self.is_ready = false
	msg.post(self.trails_pool, "get_buffer")
end

local function update_trail(self, dt)
	trail_maker.follow_position(self, self.dt)
	trail_maker.draw_trail(self)
end

function update(self, dt)
	if not self.is_ready then
		return
	end
	self.dt = dt
	if self.auto_update then
		update_trail(self, dt)
	end
end

local UPDATE = hash("update")
local RESET = hash("reset")

function on_message(self, message_id, message, sender)
	if message_id == UPDATE and self.is_ready then
		update_trail(self, message.dt or self.dt)
		
	elseif message_id == RESET then
		reset_trail(self)
		
	elseif message_id == hash("buffer_index") then
		self.mesh_vertices_resource = go.get(self.trails_pool, "buffer_" .. message.index)
		reset_trail(self)
		self.buffer_index = message.index
		self.is_ready = true
	end
end

function final(self)
	msg.post(self.trails_pool, "releace_buffer", {index=self.buffer_index})
end